# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `wavefile` gem.
# Please instead update this file by running `bin/tapioca gem wavefile`.


# source://wavefile//lib/wavefile/buffer.rb#1
module WaveFile; end

# Public: Represents a collection of samples in a certain format (e.g. 16-bit mono Integer PCM).
# Reader returns sample data contained in Buffers, and Writer expects incoming sample
# data to be contained in a Buffer as well.
#
# Contains methods to convert the sample data in the buffer to a different format.
#
# source://wavefile//lib/wavefile/buffer.rb#13
class WaveFile::Buffer
  # Public: Creates a new Buffer.
  #
  # samples - An array of samples. If the Format has 1 channel (i.e. is mono), this
  #           should be a flat array of samples such as <code>[0.5, 0.4, -0.3, ...]</code>.
  #           If the Format has 2 or more channels the array should include a sub-array for
  #           each sample frame. For example, <code>[[0.5, 0.2], [0.1, 0.6], [-0.2, 0.4], ...]</code>
  #           for a stereo file.
  #
  #           The individual samples should match the given format:
  #
  #           :pcm_8    - Integer between 0 and 255
  #           :pcm_16   - Integer between -32_768 and 32_767
  #           :pcm_24   - Integer between -8_388_608 and 8_388_607
  #           :pcm_32   - Integer between 2_147_483_648 and 2_147_483_647
  #           :float    - Float between -1.0 and 1.0
  #           :float_32 - Float between -1.0 and 1.0
  #           :float_64 - Float between -1.0 and 1.0
  #
  # format - A Format instance which describes the sample format of the sample array.
  #
  #          Note that the sample array is not compared with the format to make sure
  #          they match - you are on the honor system to make sure they do. If they
  #          don't match, unexpected things will happen.
  #
  # Examples
  #   # One cycle of a floating point 441Hz mono square wave
  #   samples = ([0.5] * 50) + ([-0.5] * 50)
  #   buffer = Buffer.new(samples, Format.new(:mono, :float, 44100))
  #
  #   # One cycle of a floating point 441Hz stereo square wave
  #   samples = ([0.5, 0.5] * 50) + ([-0.5, -0.5] * 50)
  #   buffer = Buffer.new(samples, Format.new(2, :float, 44100))
  #
  #   # One cycle of a 16-bit PCM 441Hz mono square wave
  #   samples = ([16000] * 50) + ([-16000] * 50)
  #   buffer = Buffer.new(samples, Format.new(1, :pcm_16, 44100))
  #
  # Returns a constructed Buffer.
  #
  # @return [Buffer] a new instance of Buffer
  #
  # source://wavefile//lib/wavefile/buffer.rb#53
  def initialize(samples, format); end

  # Public: Returns the bits per sample of the buffer's sample data
  #
  # source://wavefile//lib/wavefile/buffer.rb#117
  def bits_per_sample; end

  # Public: Returns the number of channels the buffer's sample data has
  #
  # source://wavefile//lib/wavefile/buffer.rb#111
  def channels; end

  # Public: Creates a new Buffer containing the sample data of this Buffer, but converted
  # to a different format.
  #
  # new_format - The format that the sample data should be converted to. If the new format
  #              has a different number of channels than the original buffer format, the sample data
  #              will be converted in the following way:
  #
  #              1 -> n: Each mono sample will be duplicated into the new number of channels.
  #
  #              n -> 1: Each sample in each sample frame will be averaged into a single sample.
  #
  #              (n > 2) -> 2: The first two channels will be kept, all other channels discarded.
  #
  #              other: Unsupported, will cause BufferConversionError to be raised.
  #
  # Examples
  #
  #   new_format = Format.new(:mono, :pcm_16, 44100)
  #   new_buffer = old_buffer.convert(new_format)
  #
  # Returns a new Buffer; the existing Buffer is unmodified.
  #
  # Raises BufferConversionError if the Buffer can't be converted to the given format
  #
  # source://wavefile//lib/wavefile/buffer.rb#82
  def convert(new_format); end

  # Public: Converts the sample data contained in the Buffer to a new format. The sample
  # data is converted in place, so the existing Buffer is modified.
  #
  # new_format - The format that the sample data should be converted to. See Buffer#convert
  #              for how samples will be mapped if the new number of channels differs from
  #              the original number of channels.
  #
  # Examples
  #
  #   new_format = Format.new(:mono, :pcm_16, 44100)
  #   old_buffer.convert!(new_format)
  #
  # Returns self.
  #
  # Raises BufferConversionError if the Buffer can't be converted to the given format
  #
  # source://wavefile//lib/wavefile/buffer.rb#103
  def convert!(new_format); end

  # Public: Returns the sample rate of the buffer's sample data
  #
  # source://wavefile//lib/wavefile/buffer.rb#123
  def sample_rate; end

  # Public: Returns the sample data contained in the Buffer as an Array. If the Format
  # has 1 channel, the Array will be a flat list of samples. If the Format has 2 or
  # more channels, the Array will include sub arrays for each sample frame, with a sample
  # for each channel.
  #
  # Examples
  #
  #   samples = mono_buffer.samples
  #   # => [-0.5, 0.3, 0.2, -0.9, ...]
  #
  #   samples = stereo_buffer.samples
  #   # => [[-0.2, 0.5], [0.1, 0.2], [-0.4, 0.7], [0.1, 0.2], ...]
  #
  #   samples = three_channel_buffer.samples
  #   # => [[0.3, 0.5, 0.2], [-0.1, 0.2, -0.9], [0.2, 0.3, -0.4], [0.1, 0.2, -0.8], ...]
  #
  # source://wavefile//lib/wavefile/buffer.rb#142
  def samples; end

  private

  # source://wavefile//lib/wavefile/buffer.rb#146
  def convert_buffer(samples, old_format, new_format); end

  # source://wavefile//lib/wavefile/buffer.rb#158
  def convert_channels(samples, old_channels, new_channels); end

  # source://wavefile//lib/wavefile/buffer.rb#182
  def convert_sample_format(samples, old_format, new_format); end

  # source://wavefile//lib/wavefile/buffer.rb#224
  def convert_sample_format_float_to_pcm(samples, old_bits_per_sample, new_bits_per_sample); end

  # source://wavefile//lib/wavefile/buffer.rb#236
  def convert_sample_format_helper(samples, &converter); end

  # source://wavefile//lib/wavefile/buffer.rb#212
  def convert_sample_format_pcm_to_float(samples, old_bits_per_sample, new_bits_per_sample); end

  # source://wavefile//lib/wavefile/buffer.rb#194
  def convert_sample_format_pcm_to_pcm(samples, old_bits_per_sample, new_bits_per_sample); end
end

# Public: Error that is raised when an attempt is made to perform an unsupported or
# undefined conversion between two sample data formats. For example, converting a Buffer
# with 4 channels into a Buffer with 3 channels is undefined.
#
# source://wavefile//lib/wavefile/buffer.rb#5
class WaveFile::BufferConversionError < ::StandardError; end

# source://wavefile//lib/wavefile.rb#19
WaveFile::CHUNK_IDS = T.let(T.unsafe(nil), Hash)

# Internal
#
# source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#2
module WaveFile::ChunkReaders; end

# Internal
#
# source://wavefile//lib/wavefile/chunk_readers/base_chunk_reader.rb#4
class WaveFile::ChunkReaders::BaseChunkReader
  # @raise [exception_class]
  #
  # source://wavefile//lib/wavefile/chunk_readers/base_chunk_reader.rb#18
  def raise_error(exception_class, message); end

  # source://wavefile//lib/wavefile/chunk_readers/base_chunk_reader.rb#5
  def read_entire_chunk_body(chunk_id); end
end

# Internal
#
# source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#4
class WaveFile::ChunkReaders::DataChunkReader < ::WaveFile::ChunkReaders::BaseChunkReader
  # @return [DataChunkReader] a new instance of DataChunkReader
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#5
  def initialize(io, chunk_size, raw_native_format, format = T.unsafe(nil)); end

  # Returns the value of attribute current_sample_frame.
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#59
  def current_sample_frame; end

  # Returns the value of attribute format.
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#59
  def format; end

  # Returns the value of attribute raw_native_format.
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#59
  def raw_native_format; end

  # @raise [UnsupportedFormatError]
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#25
  def read(sample_frame_count); end

  # Returns the value of attribute readable_format.
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#59
  def readable_format; end

  # Returns the value of attribute total_sample_frames.
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#59
  def total_sample_frames; end

  private

  # Since Ruby doesn't have a way to natively extract 24-bit values using pack/unpack,
  # unsigned bytes are read instead, and then every 3 is manually combined into a
  # signed 24-bit integer.
  # Since the sample data is little endian, the 3 bytes will go from least->most significant
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#76
  def convert_24_bit_samples(samples); end

  # The number of sample frames in the file after the current sample frame
  #
  # source://wavefile//lib/wavefile/chunk_readers/data_chunk_reader.rb#68
  def sample_frames_remaining; end
end

# Internal
#
# source://wavefile//lib/wavefile/chunk_readers/format_chunk_reader.rb#4
class WaveFile::ChunkReaders::FormatChunkReader < ::WaveFile::ChunkReaders::BaseChunkReader
  # @return [FormatChunkReader] a new instance of FormatChunkReader
  #
  # source://wavefile//lib/wavefile/chunk_readers/format_chunk_reader.rb#5
  def initialize(io, chunk_size); end

  # source://wavefile//lib/wavefile/chunk_readers/format_chunk_reader.rb#10
  def read; end
end

# source://wavefile//lib/wavefile/chunk_readers/format_chunk_reader.rb#52
WaveFile::ChunkReaders::FormatChunkReader::MINIMUM_CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# Internal: Used to read the RIFF chunks in a wave file up until the data chunk. Thus it
# can be used to open a wave file and "queue it up" to the start of the actual sample data,
# as well as extract information out of pre-data chunks, such as the format chunk.
#
# source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#6
class WaveFile::ChunkReaders::RiffReader
  # @return [RiffReader] a new instance of RiffReader
  #
  # source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#7
  def initialize(io, format = T.unsafe(nil)); end

  # Returns the value of attribute data_chunk_reader.
  #
  # source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#13
  def data_chunk_reader; end

  # Returns the value of attribute native_format.
  #
  # source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#13
  def native_format; end

  # Returns the value of attribute sample_chunk.
  #
  # source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#13
  def sample_chunk; end

  private

  # @raise [exception_class]
  #
  # source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#109
  def raise_error(exception_class, message); end

  # source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#94
  def read_chunk_header; end

  # source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#17
  def read_riff_format_code; end

  # source://wavefile//lib/wavefile/chunk_readers/riff_reader.rb#25
  def read_until_data_chunk(format); end
end

# Internal
#
# source://wavefile//lib/wavefile/chunk_readers/sample_chunk_reader.rb#4
class WaveFile::ChunkReaders::SampleChunkReader < ::WaveFile::ChunkReaders::BaseChunkReader
  # @return [SampleChunkReader] a new instance of SampleChunkReader
  #
  # source://wavefile//lib/wavefile/chunk_readers/sample_chunk_reader.rb#5
  def initialize(io, chunk_size); end

  # source://wavefile//lib/wavefile/chunk_readers/sample_chunk_reader.rb#10
  def read; end
end

# source://wavefile//lib/wavefile/chunk_readers/sample_chunk_reader.rb#70
WaveFile::ChunkReaders::SampleChunkReader::CORE_BYTE_COUNT = T.let(T.unsafe(nil), Integer)

# source://wavefile//lib/wavefile/chunk_readers/sample_chunk_reader.rb#71
WaveFile::ChunkReaders::SampleChunkReader::LOOP_BYTE_COUNT = T.let(T.unsafe(nil), Integer)

# Public: Calculates playback time given the number of sample frames and the sample rate.
# For example, you can use this to calculate how long a given Wave file is.
#
# The hours, minutes, seconds, and milliseconds fields return values like you would
# see on a stopwatch, and not the total amount of time in that unit. For example, a
# stopwatch running for exactly 2 hours would show something like "2:00:00.000".
# Accordingly, if the given sample frame count and sample rate add up to exactly
# 2 hours, then hours will be 2, and minutes, seconds, and milliseconds will all be 0.
#
# source://wavefile//lib/wavefile/duration.rb#10
class WaveFile::Duration
  # Public: Constructs a new immutable Duration.
  #
  # sample_frame_count - The number of sample frames, i.e. the number
  #                      samples in each channel.
  # sample_rate - The number of samples per second, such as 44100
  #
  # Examples:
  #
  #   duration = Duration.new(400_000_000, 44100)
  #   duration.hours         # => 2
  #   duration.minutes       # => 31
  #   duration.seconds       # => 10
  #   duration.milliseconds  # => 294
  #
  # The hours, minutes, seconds, and milliseconds fields return values like you would
  # see on a stopwatch, and not the total amount of time in that unit. For example, a
  # stopwatch running for exactly 2 hours would show something like "2:00:00.000".
  # Accordingly, if the given sample frame count and sample rate add up to exactly
  # 2 hours, then hours will be 2, and minutes, seconds, and milliseconds will all be 0.
  #
  # @return [Duration] a new instance of Duration
  #
  # source://wavefile//lib/wavefile/duration.rb#30
  def initialize(sample_frame_count, sample_rate); end

  # Public: Returns true if this Duration represents that same amount of time as
  # other_duration.
  #
  # Two Duration instances will evaluate as == if they correspond
  # to the same "stopwatch time". This means that two Durations constructed
  # from a different number of sample frames or different sample rates can be
  # considered equal if they correspond to the same amount
  # of time. For example, a Duration from 44,100 sample frames
  # at 44,100 samples/sec will be considered equal to a Duration
  # from 22,050 sample frames at 22,050 samples/sec, because
  # both correspond to 1 second of audio.
  #
  # Since the finest resolution of a duration is 1 millisecond,
  # two Durations that represent different amounts of time but
  # differ by less than 1 millisecond will be considered equal.
  #
  # source://wavefile//lib/wavefile/duration.rb#73
  def ==(other_duration); end

  # Public
  #
  # source://wavefile//lib/wavefile/duration.rb#87
  def hours; end

  # Public
  #
  # source://wavefile//lib/wavefile/duration.rb#96
  def milliseconds; end

  # Public
  #
  # source://wavefile//lib/wavefile/duration.rb#90
  def minutes; end

  # Public
  #
  # source://wavefile//lib/wavefile/duration.rb#81
  def sample_frame_count; end

  # Public
  #
  # source://wavefile//lib/wavefile/duration.rb#84
  def sample_rate; end

  # Public
  #
  # source://wavefile//lib/wavefile/duration.rb#93
  def seconds; end
end

# source://wavefile//lib/wavefile.rb#16
WaveFile::FORMAT_CODES = T.let(T.unsafe(nil), Hash)

# Public: Represents information about the data format for a Wave file, such as number of
# channels, bits per sample, sample rate, and so forth. A Format instance is used
# by Reader to indicate what format to read samples out as, and by Writer to
# indicate what format to write samples as.
#
# source://wavefile//lib/wavefile/format.rb#20
class WaveFile::Format
  # Public: Constructs a new immutable Format.
  #
  # channels - The number of channels in the format. Can either be an Integer
  #            (e.g. 1, 2, 3) or the symbols +:mono+ (equivalent to 1) or
  #            +:stereo+ (equivalent to 2).
  # format_code - A symbol indicating the format of each sample. Consists of
  #               two parts: a format code, and the bits per sample. The valid
  #               values are +:pcm_8+, +:pcm_16+, +:pcm_24+, +:pcm_32+, +:float_32+,
  #               +:float_64+, and +:float+ (equivalent to +:float_32+)
  # sample_rate - The number of samples per second, such as 44100
  # speaker_mapping - An optional array which indicates which speaker each channel should be
  #                   mapped to. Each value in the array should be one of these values:
  #
  #                   +:front_left+, +:front_right+, +:front_center+, +:low_frequency+, +:back_left+,
  #                   +:back_right+, +:front_left_of_center+, +:front_right_of_center+,
  #                   +:back_center+, +:side_left+, +:side_right+, +:top_center+, +:top_front_left+,
  #                   +:top_front_center+, +:top_front_right+, +:top_back_left+, +:top_back_center+,
  #                   +:top_back_right+.
  #
  #                   Each value should only appear once, and the channels must follow the ordering above.
  #
  #                   For example, <code>[:front_center, :back_left]</code>
  #                   is a valid speaker mapping, but <code>[:back_left, :front_center]</code> is not.
  #                   If a given channel should not be mapped to a specific speaker, the
  #                   value +:undefined+ can be used. If this field is omitted, a default
  #                   value for the given number of channels. For example, if there are 2
  #                   channels, this will be set to <code>[:front_left, :front_right]</code>.
  #
  # Examples
  #
  #   format = Format.new(1, :pcm_16, 44100)
  #   format = Format.new(:mono, :pcm_16, 44100)  # Equivalent to above
  #
  #   format = Format.new(:stereo, :float_32, 44100)
  #   format = Format.new(:stereo, :float, 44100)  # Equivalent to above
  #
  #   format = Format.new(2, :pcm_16, 44100, speaker_mapping: [:front_right, :front_center])
  #
  #   # Channels should explicitly not be mapped to particular speakers
  #   # (otherwise, if no speaker_mapping set, it will be set to a default
  #   # value for the number of channels).
  #   format = Format.new(2, :pcm_16, 44100, speaker_mapping: [:undefined, :undefined])
  #
  #   # Will result in InvalidFormatError, because speakers are defined in
  #   # invalid order
  #   format = Format.new(2, :pcm_16, 44100, speaker_mapping: [:front_right, :front_left])
  #
  #   # speaker_mapping will be set to [:front_left, :undefined, :undefined],
  #   # because channels without a speaker mapping will be mapped to :undefined
  #   format = Format.new(3, :pcm_16, 44100, speaker_mapping: [:front_left])
  #
  # Raises InvalidFormatError if the given arguments are invalid.
  #
  # @return [Format] a new instance of Format
  #
  # source://wavefile//lib/wavefile/format.rb#74
  def initialize(channels, format_code, sample_rate, speaker_mapping: T.unsafe(nil)); end

  # Public: Returns the number of bits per sample, such as 8, 16, 24, 32, or 64.
  #
  # source://wavefile//lib/wavefile/format.rb#114
  def bits_per_sample; end

  # Public: Returns the number of bytes in each sample frame. For example, in a 16-bit stereo file,
  # this will be 4 (2 bytes for each 16-bit sample, times 2 channels).
  #
  # source://wavefile//lib/wavefile/format.rb#121
  def block_align; end

  # Public: Returns the number of bytes contained in 1 second of sample data.
  # Is equivalent to #block_align * #sample_rate.
  #
  # source://wavefile//lib/wavefile/format.rb#125
  def byte_rate; end

  # Public: Returns the number of channels, such as 1 or 2. This will always return a
  # Integer, even if the number of channels is specified with a symbol (e.g. +:mono+)
  # in the constructor.
  #
  # source://wavefile//lib/wavefile/format.rb#108
  def channels; end

  # Public: Returns true if the format has 1 channel, false otherwise.
  #
  # @return [Boolean]
  #
  # source://wavefile//lib/wavefile/format.rb#96
  def mono?; end

  # Public: Returns a symbol indicating the sample format, such as +:pcm+ or +:float+
  #
  # source://wavefile//lib/wavefile/format.rb#111
  def sample_format; end

  # Public: Returns the number of samples per second, such as 44100.
  #
  # source://wavefile//lib/wavefile/format.rb#117
  def sample_rate; end

  # Public: Returns the mapping of each channel to a speaker.
  #
  # source://wavefile//lib/wavefile/format.rb#128
  def speaker_mapping; end

  # Public: Returns true if the format has 2 channels, false otherwise.
  #
  # @return [Boolean]
  #
  # source://wavefile//lib/wavefile/format.rb#101
  def stereo?; end

  private

  # Internal
  #
  # source://wavefile//lib/wavefile/format.rb#179
  def default_speaker_mapping(channels); end

  # Internal
  #
  # source://wavefile//lib/wavefile/format.rb#141
  def normalize_channels(channels); end

  # Internal
  #
  # source://wavefile//lib/wavefile/format.rb#152
  def normalize_format_code(format_code); end

  # Internal
  #
  # source://wavefile//lib/wavefile/format.rb#162
  def normalize_speaker_mapping(channels, speaker_mapping); end

  # Internal
  #
  # source://wavefile//lib/wavefile/format.rb#212
  def validate_channels(candidate_channels); end

  # Internal
  #
  # source://wavefile//lib/wavefile/format.rb#220
  def validate_format_code(candidate_format_code); end

  # Internal
  #
  # source://wavefile//lib/wavefile/format.rb#228
  def validate_sample_rate(candidate_sample_rate); end

  # Internal
  #
  # @raise [InvalidFormatError]
  #
  # source://wavefile//lib/wavefile/format.rb#236
  def validate_speaker_mapping(channels, candidate_speaker_mapping); end
end

# Internal
#
# source://wavefile//lib/wavefile/format.rb#138
WaveFile::Format::SUPPORTED_FORMAT_CODES = T.let(T.unsafe(nil), Array)

# Internal
#
# source://wavefile//lib/wavefile/format.rb#133
WaveFile::Format::VALID_CHANNEL_RANGE = T.let(T.unsafe(nil), Range)

# Internal
#
# source://wavefile//lib/wavefile/format.rb#135
WaveFile::Format::VALID_SAMPLE_RATE_RANGE = T.let(T.unsafe(nil), Range)

# Public: Error that is raised when a file is not in a format supported by this Gem.
# For example, because it's a valid Wave file whose format is not supported by
# this Gem. Or, because it's a not a valid Wave file period.
#
# source://wavefile//lib/wavefile/format.rb#5
class WaveFile::FormatError < ::StandardError; end

# Public: Error that is raised when constructing a Format instance that is not valid,
# trying to read from a file that is not a wave file, or trying to read from a file
# that is not valid according to the wave file spec.
#
# source://wavefile//lib/wavefile/format.rb#10
class WaveFile::InvalidFormatError < ::WaveFile::FormatError; end

# Public: Error that is raised when constructing a SMPTETimecode instance that is not valid.
# Valid means that each field is in the range that can be encoded in a *.wav file, but not
# not necessarily semantically correct. For example, a SMPTETimecode field can be constructed
# with a hours value of 100, even though this isn't a valid value in real life.
#
# source://wavefile//lib/wavefile/smpte_timecode.rb#6
class WaveFile::InvalidSMPTETimecodeError < ::StandardError; end

# Public: Error that is raised when constructing a SamplerInfo instance that is invalid.
#         "Invalid" means that one or more fields have a value that can't be encoded in the
#         field inside a *.wav file. For example, there's no way to encode "-23" as a value
#         for the midi_note field. However, this error _won't_ be raised for values that
#         can be encoded, but aren't semantically correct. For example, it's possible to
#         construct a SamplerInfo instance with a midi_note value of 10000, which can be
#         encoded in a *.wav file, even though this isn't a valid value in real life.
#
# source://wavefile//lib/wavefile/sampler_info.rb#9
class WaveFile::InvalidSamplerInfoError < ::StandardError; end

# Public: Error that is raised when constructing a SamplerLoop instance that is invalid.
#         "Invalid" means that one or more fields have a value that can't be encoded in the
#         field inside a *.wav file. For example, there's no way to encode "-23" as a value
#         for the start_sample_frame field. However, this error _won't_ be raised for values
#         that can be encoded, but aren't semantically correct. For example, it's possible
#         to set the start_sample_frame or end_sample_frame fields to values that don't
#         correspond to the actual sample frame range of the file. This error _won't_ be
#         raised for "encodeable but not semantically valid" field values.
#
# source://wavefile//lib/wavefile/sampler_loop.rb#10
class WaveFile::InvalidSamplerLoopError < ::StandardError; end

# source://wavefile//lib/wavefile.rb#33
WaveFile::PACK_CODES = T.let(T.unsafe(nil), Hash)

# Public: Provides the ability to read sample data out of a wave file, as well as query
# a wave file about its metadata (e.g. number of channels, sample rate, etc).
#
# When constructing a Reader a block can be given. All data should be read inside this
# block, and when the block exits the Reader will automatically be closed.
#
#     Reader.new("my_file.wav") do |reader|
#       # Read sample data here
#     end
#
# Alternately, if a block isn't given you should make sure to call close when finished reading.
#
#     reader = Reader.new("my_file.wav")
#     # Read sample data here
#     reader.close
#
# source://wavefile//lib/wavefile/reader.rb#20
class WaveFile::Reader
  # Public: Constructs a Reader object that is ready to start reading the specified file's
  # sample data.
  #
  # io_or_file_name - The name of the wave file to read from,
  #                   or an open IO object to read from.
  # format - The format that read sample data should be returned in
  #          (default: the wave file's internal format).
  #
  # Returns a Reader object that is ready to start reading the specified file's sample data.
  #
  # Raises +Errno::ENOENT+ if the specified file can't be found.
  #
  # Raises InvalidFormatError if the specified file isn't a valid wave file.
  #
  # @return [Reader] a new instance of Reader
  #
  # source://wavefile//lib/wavefile/reader.rb#34
  def initialize(io_or_file_name, format = T.unsafe(nil)); end

  # Public: Closes the Reader. If the Reader is already closed, does nothing. After a Reader
  # is closed, no more sample data can be read from it. Note: If the Reader is constructed
  # from an open IO instance (as opposed to a file name), the IO instance will _not_ be closed.
  # You'll have to manually close it yourself. This is intentional, because Reader can't know
  # what you may/may not want to do with the IO instance in the future.
  #
  # Returns nothing.
  #
  # source://wavefile//lib/wavefile/reader.rb#153
  def close; end

  # Public: Returns true if the Reader is closed, and false if it is open and available for reading.
  #
  # @return [Boolean]
  #
  # source://wavefile//lib/wavefile/reader.rb#141
  def closed?; end

  # Public: Returns the index of the sample frame which is "cued up" for reading. I.e., the index
  # of the next sample frame that will be read. A sample frame contains a single sample
  # for each channel. So if there are 1,000 sample frames in a stereo file, this means
  # there are 1,000 left-channel samples and 1,000 right-channel samples.
  #
  # source://wavefile//lib/wavefile/reader.rb#196
  def current_sample_frame; end

  # Public: Starting from the current reading position, reads sample frames into successive Buffers
  # of the specified size, until there are no more sample frames to be read. When the final sample
  # frame has been read the Reader is automatically closed. Each Buffer is passed to the given block.
  #
  # If the Reader is constructed from an open IO, the IO is NOT closed after all sample data is
  # read. However, the Reader will be closed and any attempt to continue to read from it will
  # result in an error.
  #
  # Note that sample_frame_count indicates the number of sample frames to read, not number of samples.
  # A sample frame include one sample for each channel. For example, if sample_frame_count is 1024, then
  # for a stereo file 1024 samples will be read from the left channel, and 1024 samples will be read from
  # the right channel.
  #
  # sample_frame_count - The number of sample frames to read into each Buffer from each channel. The number
  #                      of sample frames read into the final Buffer could be less than this size, if there
  #                      are not enough remaining.
  #
  # Examples
  #
  #   # sample_frame_count not given, so default buffer size
  #   Reader.new("my_file.wav").each_buffer do |buffer|
  #     puts "#{buffer.samples.length} sample frames read"
  #   end
  #
  #   # Specific sample_frame_count given for each buffer
  #   Reader.new("my_file.wav").each_buffer(1024) do |buffer|
  #     puts "#{buffer.samples.length} sample frames read"
  #   end
  #
  #   # Reading each buffer from an externally created IO
  #   file = File.open("my_file.wav", "rb")
  #   Reader.new(file).each_buffer do |buffer|
  #     puts "#{buffer.samples.length} sample frames read"
  #   end
  #   # Although Reader is closed, file still needs to be manually closed
  #   file.close
  #
  #   reader = Reader.new("my_file.wav")
  #   reader.read(100)
  #   # Reading using `each_buffer` will start at the 101st sample frame:
  #   reader.each_buffer do |buffer|
  #     puts "#{buffer.samples.length} sample frames read"
  #   end
  #   # At this point, the Reader is now closed (even without
  #   # a call to `close()`)
  #
  # Returns nothing. Has side effect of closing the Reader.
  #
  # source://wavefile//lib/wavefile/reader.rb#106
  def each_buffer(sample_frame_count = T.unsafe(nil)); end

  # Public: Returns an object describing how sample data is being read from the Wave file.
  # I.e., number of channels, bits per sample, sample format, etc. If #readable_format? is
  # true, then this will be a Format object. The format the samples are read out as might
  # be different from how the samples are actually stored in the file. Therefore, #format
  # might not match #native_format. If #readable_format? is false, then this will return the
  # same value as #native_format.
  #
  # source://wavefile//lib/wavefile/reader.rb#188
  def format; end

  # Public: Returns an object describing the sample format of the Wave file being read.
  # This returns the data contained in the "fmt " chunk of the Wave file. It will not
  # necessarily match the format that the samples are read out as (for that, see #format).
  #
  # source://wavefile//lib/wavefile/reader.rb#171
  def native_format; end

  # Public: Reads the specified number of sample frames from the wave file into a Buffer. Note that the Buffer
  # will have at most sample_frame_count sample frames, but could have less if the file doesn't have enough
  # remaining.
  #
  # sample_frame_count - The number of sample frames to read. Note that each sample frame includes a sample for
  #                      each channel.
  #
  # Returns a Buffer containing sample_frame_count sample frames.
  #
  # Raises UnsupportedFormatError if file is in a format that can't be read by this gem.
  #
  # Raises ReaderClosedError if the Reader has been closed.
  #
  # Raises EOFError if no samples could be read due to reaching the end of the file.
  #
  # source://wavefile//lib/wavefile/reader.rb#131
  def read(sample_frame_count); end

  # Public: Returns true if this is a valid Wave file and contains sample data that is in a format
  # that this class can read, and returns false if this is a valid Wave file but does not
  # contain a sample format that this gem knows how to read.
  #
  # @return [Boolean]
  #
  # source://wavefile//lib/wavefile/reader.rb#178
  def readable_format?; end

  # Public: Returns a SamplerInfo object if the file contains "smpl" chunk, or nil if it doesn't.
  # If present, this will contain information about how the file can be use by a sampler, such as
  # corresponding MIDI note, or loop points.
  #
  # source://wavefile//lib/wavefile/reader.rb#210
  def sampler_info; end

  # Public: Returns a Duration instance which indicates the playback time of the file.
  #
  # source://wavefile//lib/wavefile/reader.rb#164
  def total_duration; end

  # Public: Returns the total number of sample frames in the file. A sample frame contains a single
  # sample for each channel. So if there are 1,000 sample frames in a stereo file, this means
  # there are 1,000 left-channel samples and 1,000 right-channel samples.
  #
  # source://wavefile//lib/wavefile/reader.rb#203
  def total_sample_frames; end
end

# Public: Error that is raised when trying to read from a Reader instance that has been closed.
#
# source://wavefile//lib/wavefile/reader.rb#3
class WaveFile::ReaderClosedError < ::IOError; end

# Public: Represents an SMPTE timecode: https://en.wikipedia.org/wiki/SMPTE_timecode
#         If a *.wav file has a "smpl" chunk, then Reader#sampler_info#smpte_offset
#         will return an instance of this class.
#
# source://wavefile//lib/wavefile/smpte_timecode.rb#11
class WaveFile::SMPTETimecode
  # Public: Constructs a new SMPTETimecode instance.
  #
  # Raises InvalidSMPTETimecodeError if the given arguments can't be written to a *.wav file.
  #
  # @return [SMPTETimecode] a new instance of SMPTETimecode
  #
  # source://wavefile//lib/wavefile/smpte_timecode.rb#21
  def initialize(hours: T.unsafe(nil), minutes: T.unsafe(nil), seconds: T.unsafe(nil), frames: T.unsafe(nil)); end

  # Returns the value of attribute frames.
  #
  # source://wavefile//lib/wavefile/smpte_timecode.rb#39
  def frames; end

  # Returns the value of attribute hours.
  #
  # source://wavefile//lib/wavefile/smpte_timecode.rb#36
  def hours; end

  # Returns the value of attribute minutes.
  #
  # source://wavefile//lib/wavefile/smpte_timecode.rb#37
  def minutes; end

  # Returns the value of attribute seconds.
  #
  # source://wavefile//lib/wavefile/smpte_timecode.rb#38
  def seconds; end

  private

  # @raise [ArgumentError]
  #
  # source://wavefile//lib/wavefile/smpte_timecode.rb#43
  def required(keyword); end

  # source://wavefile//lib/wavefile/smpte_timecode.rb#54
  def validate_8_bit_signed_integer_field(candidate, field_name); end

  # source://wavefile//lib/wavefile/smpte_timecode.rb#47
  def validate_8_bit_unsigned_integer_field(candidate, field_name); end
end

# source://wavefile//lib/wavefile/smpte_timecode.rb#14
WaveFile::SMPTETimecode::VALID_8_BIT_SIGNED_INTEGER_RANGE = T.let(T.unsafe(nil), Range)

# source://wavefile//lib/wavefile/smpte_timecode.rb#12
WaveFile::SMPTETimecode::VALID_8_BIT_UNSIGNED_INTEGER_RANGE = T.let(T.unsafe(nil), Range)

# source://wavefile//lib/wavefile.rb#18
WaveFile::SUB_FORMAT_GUID_FLOAT = T.let(T.unsafe(nil), String)

# source://wavefile//lib/wavefile.rb#17
WaveFile::SUB_FORMAT_GUID_PCM = T.let(T.unsafe(nil), String)

# Public: Provides a way to indicate the data contained in a "smpl" chunk.
#         That is, information about how the *.wav file could be used by a
#         sampler, such as the file's MIDI note or loop points. If a *.wav
#         file contains a "smpl" chunk, then Reader#sampler_info will
#         return an instance of this object with the relevant info.
#
# source://wavefile//lib/wavefile/sampler_info.rb#16
class WaveFile::SamplerInfo
  # Public: Constructs a new SamplerInfo instance.
  #
  # manufacturer_id - the ID of the manufacturer that this sample is intended for. If it's not
  #                   intended for a sampler from a particular manufacturer, this should be 0.
  #                   See the list at https://www.midi.org/specifications-old/item/manufacturer-id-numbers
  # product_id - the ID of the product made by the manufacturer this sample is intended for.
  #              If not intended for a particular product, this should be 0.
  # sample_nanoseconds - the length of each sample in nanoseconds, which is typically determined by
  #                      converting <code>1 / sample rate</code> (in seconds) into nanoseconds.
  #                      For example, with a sample rate of 44100 this would be 22675 nanoseconds. However,
  #                      this can be set to an arbitrary value to allow for fine tuning.
  # midi_note - the MIDI note number of the sample. Should be between 0 and 127.
  # fine_tuning_cents - the number of cents >= 0.0 and < 100.0 the note should be tuned up from the midi_note
  #                     field. 100 cents is equal to one semitone. For example, if this value is 50.0, and
  #                     midi_note is 60, then the sample is tuned half-way between MIDI note 60 and 61. If the
  #                     value is 0, then the sample has no fine tuning.
  # smpte_format - the SMPTE format. Should be 0, 24, 25, 29 or 30.
  # smpte_offset - a SMPTETimecode representing the SMPTE time offset.
  # loops - an Array of 0 or more SamplerLoop objects containing loop point info. Loop point info
  #         can indicate that (for example) the sampler should loop between a given sample range as long
  #         as the sample is played.
  # sampler_specific_data - a String of data specific to the intended target sampler, or nil if there is no sampler
  #                         specific data.
  #
  # Raises InvalidSamplerInfoError if the given arguments are can't be written to a *.wav file.
  #
  # @return [SamplerInfo] a new instance of SamplerInfo
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#46
  def initialize(manufacturer_id: T.unsafe(nil), product_id: T.unsafe(nil), sample_nanoseconds: T.unsafe(nil), midi_note: T.unsafe(nil), fine_tuning_cents: T.unsafe(nil), smpte_format: T.unsafe(nil), smpte_offset: T.unsafe(nil), loops: T.unsafe(nil), sampler_specific_data: T.unsafe(nil)); end

  # Public: Returns the number of cents >= 0.0 and < 100.0 the note should be tuned up from the midi_note
  #         field. 100 cents is equal to one semitone. For example, if this value is 50, and midi_note is
  #         60, then the sample is tuned half-way between MIDI note 60 and 61. If the value is 0, then the
  #         sample has no fine tuning.
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#98
  def fine_tuning_cents; end

  # Public: Returns an Array of 0 or more SamplerLoop objects containing loop point info. Loop point info
  #         can indicate that (for example) the sampler should loop between a given sample range as long
  #         as the sample is played.
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#109
  def loops; end

  # Public: Returns the ID of the manufacturer that this sample is intended for. If it's not
  #         intended for a sampler from a particular manufacturer, this should be 0.
  #         See the list at https://www.midi.org/specifications-old/item/manufacturer-id-numbers
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#79
  def manufacturer_id; end

  # Public: Returns the MIDI note number of the sample, which normally should be between 0 and 127.
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#92
  def midi_note; end

  # Public: Returns the ID of the product made by the manufacturer this sample is intended for.
  #         If not intended for a particular product, this should be 0.
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#83
  def product_id; end

  # Public: Returns the length of each sample in nanoseconds, which is typically determined by
  #         converting <code>1 / sample rate</code> (in seconds) into nanoseconds. For example,
  #         with a sample rate of 44100 this would be 22675 nanoseconds. However, this can be set
  #         to an arbitrary value to allow for fine tuning.
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#89
  def sample_nanoseconds; end

  # Public: Returns a String of data specific to the intended target sampler, or nil if there is no sampler
  #         specific data. This is returned as a raw String because the structure of this data depends on
  #         the specific sampler. If you want to use it, you'll need to unpack the String yourself.
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#114
  def sampler_specific_data; end

  # Public: Returns the SMPTE format (0, 24, 25, 29 or 30)
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#101
  def smpte_format; end

  # Public: Returns a SMPTETimecode representing the SMPTE time offset.
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#104
  def smpte_offset; end

  private

  # @raise [ArgumentError]
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#118
  def required(keyword); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#123
  def validate_32_bit_integer_field(candidate, field_name); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#131
  def validate_fine_tuning_cents(candidate); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#147
  def validate_loops(candidate); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#155
  def validate_sampler_specific_data(candidate); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_info.rb#139
  def validate_smpte_offset(candidate); end
end

# source://wavefile//lib/wavefile/sampler_info.rb#17
WaveFile::SamplerInfo::VALID_32_BIT_INTEGER_RANGE = T.let(T.unsafe(nil), Range)

# Public: Provides a way to indicate the data about sampler loop points
#         in a file's "smpl" chunk. That is, information about how a sampler
#         could loop between a sample range while playing this *.wav as a note.
#         If a *.wav file contains a "smpl" chunk, then Reader#sampler_info#loops
#         will return an array of SamplerLoop objects with the relevant info.
#
# source://wavefile//lib/wavefile/sampler_loop.rb#17
class WaveFile::SamplerLoop
  # Public: Constructs a new SamplerLoop instance.
  #
  # id - A numeric ID which identifies the specific loop. Should be an Integer 0 or greater.
  # type - Indicates which direction the loop should run. Should either be one of the symbols
  #        +:forward+, +:alternating+, +:backward+, or a positive Integer. If an Integer, then 0 will
  #        be normalized to +:forward+, 1 to +:alternating+, 2 to +:backward+. Integer values 3 or
  #        greater are allowed by the *.wav file spec, but don't necessarily have a defined meaning.
  # start_sample_frame - The first sample frame in the loop.
  # end_sample_frame - The last sample frame in the loop.
  # fraction - A Float >= 0.0 and < 1.0 which specifies a fraction of a sample at which to start
  #            the loop. This allows a loop start to be fine tuned at a resolution finer than one sample.
  # play_count - The number of times to loop. Can be an Integer 0 or greater, or Float::INFINITY.
  #              A value of 0 will be normalized to Float::INFINITY, because in the file format a
  #              value of 0 means to repeat the loop indefinitely.
  #
  # Raises InvalidSamplerLoopError if the given arguments can't be written to a *.wav file.
  #
  # @return [SamplerLoop] a new instance of SamplerLoop
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#40
  def initialize(id: T.unsafe(nil), type: T.unsafe(nil), start_sample_frame: T.unsafe(nil), end_sample_frame: T.unsafe(nil), fraction: T.unsafe(nil), play_count: T.unsafe(nil)); end

  # Public: Returns the last sample frame of the loop.
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#78
  def end_sample_frame; end

  # Public: A value >= 0.0 and < 1.0 which specifies a fraction of a sample at which to loop.
  #         This allows a loop to be fine tuned at a resolution finer than one sample.
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#82
  def fraction; end

  # Public: Returns a numeric ID which identifies the specific loop
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#67
  def id; end

  # Public: Returns the number of times to loop. Will be an Integer 1 or greater, or Float::INFINITY.
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#85
  def play_count; end

  # Public: Returns the first sample frame of the loop.
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#75
  def start_sample_frame; end

  # Public: Returns a symbol indicating which direction the loop should run. The possible values
  #         are :forward, :alternating, :backward, or a positive Integer. Integer values 3 or greater
  #         are allowed by the *.wav file spec, but don't necessarily have a defined meaning.
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#72
  def type; end

  private

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#94
  def normalize_type(type); end

  # @raise [ArgumentError]
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#89
  def required(keyword); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#111
  def validate_32_bit_integer_field(candidate, field_name); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#127
  def validate_fraction(candidate); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#119
  def validate_loop_type(candidate); end

  # Internal
  #
  # source://wavefile//lib/wavefile/sampler_loop.rb#135
  def validate_play_count(candidate); end
end

# source://wavefile//lib/wavefile/sampler_loop.rb#18
WaveFile::SamplerLoop::VALID_32_BIT_INTEGER_RANGE = T.let(T.unsafe(nil), Range)

# source://wavefile//lib/wavefile/sampler_loop.rb#20
WaveFile::SamplerLoop::VALID_LOOP_TYPES = T.let(T.unsafe(nil), Array)

# source://wavefile//lib/wavefile.rb#36
WaveFile::UNSIGNED_INT_16 = T.let(T.unsafe(nil), String)

# source://wavefile//lib/wavefile.rb#37
WaveFile::UNSIGNED_INT_32 = T.let(T.unsafe(nil), String)

# Public: Error that is raised when trying to read from a valid wave file that has its sample data
# stored in a format that Reader doesn't understand.
#
# source://wavefile//lib/wavefile/format.rb#14
class WaveFile::UnsupportedFormatError < ::WaveFile::FormatError; end

# Represents information about the data format for a Wave file, such as number of
# channels, bits per sample, sample rate, and so forth. A Format instance is used
# by Reader to indicate what format to read samples out as, and by Writer to
# indicate what format to write samples as.
#
# source://wavefile//lib/wavefile/unvalidated_format.rb#7
class WaveFile::UnvalidatedFormat < ::WaveFile::Format
  # Constructs a new immutable UnvalidatedFormat.
  #
  # @return [UnvalidatedFormat] a new instance of UnvalidatedFormat
  #
  # source://wavefile//lib/wavefile/unvalidated_format.rb#8
  def initialize(fields); end

  # Returns the value of attribute audio_format.
  #
  # source://wavefile//lib/wavefile/unvalidated_format.rb#20
  def audio_format; end

  # Returns the value of attribute sub_audio_format_guid.
  #
  # source://wavefile//lib/wavefile/unvalidated_format.rb#20
  def sub_audio_format_guid; end

  # source://wavefile//lib/wavefile/unvalidated_format.rb#22
  def to_validated_format; end

  # Returns the value of attribute valid_bits_per_sample.
  #
  # source://wavefile//lib/wavefile/unvalidated_format.rb#20
  def valid_bits_per_sample; end

  private

  # Internal
  #
  # source://wavefile//lib/wavefile/unvalidated_format.rb#59
  def parse_speaker_mapping(bit_field); end
end

# Internal
#
# source://wavefile//lib/wavefile/unvalidated_format.rb#78
WaveFile::UnvalidatedFormat::SPEAKER_POSITIONS = T.let(T.unsafe(nil), Array)

# source://wavefile//lib/wavefile.rb#13
WaveFile::VERSION = T.let(T.unsafe(nil), String)

# source://wavefile//lib/wavefile.rb#15
WaveFile::WAVEFILE_FORMAT_CODE = T.let(T.unsafe(nil), String)

# Public: Provides the ability to write data to a wave file.
#
# When a Writer is constructed it can be given a block. All samples should be written inside this
# block, and when the block exits the file will automatically be closed:
#
#    Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
#      # Write sample data here
#    end
#
# If no block is given, you'll need to manually close the Writer when done. The underlaying
# file will not be valid or playable until #close is called.
#
#    writer = Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100))
#    # Write sample data here
#    writer.close
#
# source://wavefile//lib/wavefile/writer.rb#20
class WaveFile::Writer
  # Public: Constructs a Writer object which is available for writing sample data to the specified file
  # (via the write method). When all sample data has been written, the Writer should be closed. Note
  # that the wave file being written to will NOT be valid (and playable in other programs) until the
  # Writer has been closed.
  #
  # If a block is given to this method, sample data can be written inside the given block. When the
  # block terminates, the Writer will be automatically closed (and no more sample data can be written).
  #
  # If no block is given, then sample data can be written until the close method is called.
  #
  # io_or_file_name - The name of the wave file to read from, or an open IO object to read from.
  #                   Only implementations of IO that support seeking are supported, because
  #                   closing the Writer requires seeking back to the beginning of the file to
  #                   update information in the file's header.
  # format - The sample data format that the file should contain
  #
  # Returns a Writer object that is ready to start writing the specified file's sample data.
  #
  # @return [Writer] a new instance of Writer
  #
  # source://wavefile//lib/wavefile/writer.rb#39
  def initialize(io_or_file_name, format); end

  # Public: Closes the Writer. After a Writer is closed, no more sample data can be written
  # to it.
  #
  # Note that the wave file will NOT be valid until this method is called. The wave file
  # format requires certain information about the amount of sample data, and this can't be
  # determined until all samples have been written. (This method doesn't need to be called
  # when passing a block to Writer.new, as this method will automatically be called when
  # the block exits).
  #
  # If you initialized the Writer with an externally created IO instance, note that
  # the IO instance won't be closed when the Writer is closed. You'll need to manually close
  # the IO yourself. This is on purpose, because the Writer can't know what you may/may not
  # want to do with the IO after closing the Writer.
  #
  # Examples
  #
  #   square_wave_samples = ([0.5] * 100) + ([-0.5] * 100)
  #   buffer = Buffer.new(square_wave_samples, Format.new(1, :float, 44100))
  #
  #   # Basic example of closing a Writer
  #   writer = Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100))
  #   writer.write(buffer)
  #   writer.close
  #   writer.close # Does nothing, since Writer is already closed
  #
  #   # Closing a Writer writing to an externally opened IO
  #   file = File.open("my_file.wav", "wb")
  #   writer = Writer.new(file, Format.new(:mono, :pcm_16, 44100))
  #   writer.close
  #   # file is still open at this point, so it should be manually closed
  #   file.close
  #
  #   # Trying to write to a Writer that has already been closed
  #   writer = Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100))
  #   writer.close
  #   # This will raise WriterClosedError, since the Writer is already closed
  #   writer.write(buffer)
  #
  #   # close() needs to be called for the Wave file to be valid
  #   writer = Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100))
  #   writer.write(buffer)
  #   exit
  #   # At this point "my_file.wav" won't be a valid Wave file, because close
  #   # was never called
  #
  #   # But, close() doesn't need to be called when constructing the Writer
  #   # with a block, because it is automatically called when the block exits.
  #   Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  #     writer.write(buffer)
  #   end
  #   # Writer is automatically closed here, because block has exited
  #
  # Returns nothing. Has side effect of closing the Writer. If the Writer is already
  # closed, does nothing.
  #
  # source://wavefile//lib/wavefile/writer.rb#180
  def close; end

  # Public: Returns true if the Writer is closed, and false if it is open and available
  # for writing.
  #
  # @return [Boolean]
  #
  # source://wavefile//lib/wavefile/writer.rb#121
  def closed?; end

  # Public: Returns a Format object describing the Wave file being written (number of channels, sample
  # format and bits per sample, sample rate, etc.)
  #
  # source://wavefile//lib/wavefile/writer.rb#218
  def format; end

  # Public: Returns a Duration instance for the number of sample frames that have been written so far
  #
  # source://wavefile//lib/wavefile/writer.rb#212
  def total_duration; end

  # Public: Returns the number of samples (per channel) that have been written to the file so far.
  # For example, if 1000 "left" samples and 1000 "right" samples have been written to a stereo file,
  # this will return 1000.
  #
  # source://wavefile//lib/wavefile/writer.rb#223
  def total_sample_frames; end

  # Public: Appends the sample data in the given Buffer to the end of the wave file.
  #
  # buffer - A Buffer instance containing the sample data to be written to the
  #          file. The format of the Buffer doesn't have to match the format of the
  #          file being written to by the Writer - if it doesn't match, it will
  #          automatically be converted to the correct format.
  #
  # Examples
  #
  #   square_wave_samples = ([0.5] * 100) + ([-0.5] * 100)
  #   buffer = Buffer.new(square_wave_samples, Format.new(1, :float, 44100))
  #
  #   Writer.new("my_file.wav", Format.new(:stereo, :pcm_16, 44100)) do |writer|
  #     writer.write(buffer)
  #   end
  #
  #   writer = Writer.new("my_file.wav", Format.new(:stereo, :pcm_16, 44100))
  #   writer.write(buffer)
  #   writer.close
  #   # This will raise WriterClosedError because the Writer has already been closed.
  #   writer.write(buffer)
  #
  # Returns the number of sample frames that have been written to the file so far.
  #
  # Raises WriterClosedError if the Writer has been closed.
  #
  # Raises BufferConversionError if the Buffer can't be converted to the Writer's format.
  #
  # source://wavefile//lib/wavefile/writer.rb#100
  def write(buffer); end

  private

  # Internal
  #
  # source://wavefile//lib/wavefile/writer.rb#274
  def pack_speaker_mapping(speaker_mapping); end

  # Internal
  # Writes the RIFF chunk header, format chunk, and the header for the data chunk. After this
  # method is called the file will be "queued up" and ready for writing actual sample data.
  #
  # source://wavefile//lib/wavefile/writer.rb#283
  def write_header(sample_frame_count); end
end

# Internal
# The number of bytes at the beginning of a wave file before the sample data in the data chunk
# starts, assuming this canonical format:
#
# RIFF Chunk Header (12 bytes)
# Format Chunk (16 bytes for PCM, 18 bytes for floating point, 40 bytes for WAVE_FORMAT_EXTENSIBLE)
# FACT Chunk (0 bytes for PCM, 12 bytes for any other format)
# Data Chunk Header (8 bytes)
#
# All wave files written by Writer use this canonical format.
#
# source://wavefile//lib/wavefile/writer.rb#245
WaveFile::Writer::CANONICAL_HEADER_BYTE_LENGTH = T.let(T.unsafe(nil), Hash)

# Internal
# Padding value written to the end of chunks whose payload is an odd number of bytes. The RIFF
# specification requires that each chunk be aligned to an even number of bytes, even if the byte
# count is an odd number.
#
# See http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/riffmci.pdf, page 11.
#
# source://wavefile//lib/wavefile/writer.rb#233
WaveFile::Writer::EMPTY_BYTE = T.let(T.unsafe(nil), String)

# Internal
#
# source://wavefile//lib/wavefile/writer.rb#248
WaveFile::Writer::FORMAT_CHUNK_BYTE_LENGTH = T.let(T.unsafe(nil), Hash)

# Internal
#
# source://wavefile//lib/wavefile/writer.rb#251
WaveFile::Writer::SPEAKER_MAPPING_BIT_VALUES = T.let(T.unsafe(nil), Hash)

# Public: Error that is raised when trying to write to a Writer instance that has been closed.
#
# source://wavefile//lib/wavefile/writer.rb#3
class WaveFile::WriterClosedError < ::IOError; end
